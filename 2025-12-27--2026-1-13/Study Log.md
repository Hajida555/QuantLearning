# 2025
##  12-27
1. 函数应用和映射
  - numpy的函数可以对pandas的对象使用(例如np.abs(DataFrame) or 多个值组成的Series)
  - 并且可以具体使用到行和列中(例如使用DataFrame.**apply**(函数) 默认为列)
  - 对于元素级的Python的函数可以使用**map**
2. 排列和排名（类似sql）
  - sort_index() 对于Series or DataFrame默认按索引排列和升序 降序ascendin=False
  - sort_values() 则是按值排列 当对DataFrame排序时，可以使用一列或多列的的数据作为排序键
  - 任何缺失值都会放到Series的末尾 反过来na_position="first"
  - rank() 为数据的值排名 默认相同的值取平均数(例如 1 2 2.5 2.5)
  - 如果想让rank按原数据中出现的顺序排名 method="first" 这样会从最小值1一直排到底
  - rank的降序也与排列一样 ascendin=False
  - 同样rank可以使用一列或多列的的数据作为排名键
3. 对于带有重复标签的索引的处理
  - 对index使用is_unique可以得知索引是否是唯一的
  - if 索引对应多个值 return Series if 为单个则与平常一样 return 单个值
  - 对DataFrame同样生效
  - 但是上述操作会使代码复杂化
## 12-28
1.  3Blue1Brown学习了指数函数求导和隐函数求导
  - 指数函数在在短时的变化率等于自身乘以一个常数 当底数为e时 常数为一
  - 通过链式法则 推出e^常数*t = 常数^t
  - 当x发生短时变化，y也随之变化 求导求的就是变化的比例
  - 当x和y给定一个，有对应的另一个便是隐形函数 求导只是链式法则的灵活运用
2. 普林斯顿第三章 极限
  - 更系统的复习一遍
3. 汇总统计和间接统计
  - sum and mean等 对na不同情况的处理方式 汇总统计
  - idxmax and idmin等 输出列和行的是索引 间接统计 
  - cumsum 每一行向下列不停加 累加统计
  - descible 一次性输出多种汇总统计
4. 获取a股股票数据的工具推进
  - bs.query_history_k_data_plus函数的初步认识
5. 整理和反思
  - 将这学期之前所学的excel sql整理
  - 大部分都已经遗忘 需要找时间重新温习
  - 许多知识还没有彻底掌握 需要多加记录和巩固
## 12-29
1. 矩阵消元和方程组的几何解释 MIT
  - 通过向量和图形来求解二维和三维的方程组 与3b1b的图形解释相像
  - 向量的和矩阵的多种乘法
  - 用矩阵消元做出下三角行列式 回代解方程组
  - 矩阵乘法不同的行列相乘
  - 作了一点课后习题
2. 完成获取a股股票数据的工具
  - 处理数据为df 文件名称正常 不同系统路径的格式 
3. 使用导出数据 了解相关系数和协方差
  - 相关系数CORR 协方差cov
  - 相关系数表明两个数据之间的关联有多强 1-0 越大越有关系
  - 协方差表明两个数据之间是否同向 正数为同一个方向 负数两个数据为反向
4. 唯一值、计数及成员属性
  - uniques去重复无排序 加sort()排序
  - value_counts 计算值出现的频次 按降序
  - isin筛选条件并返回布尔值可为数据集过滤为子集
  - index.get_indexer 根据一个索引列表对提供的有重复的列表 输出重复列表在索引的位置
  - data.apply(lambda obj: pd.Series(obj).value_counts()).fillna(0) 对df中出现过的所有值在不同列出现次数计数
  - df.value_counts() 则是按照每一行为元组进行计数
## 12-30
1. 矩阵的多种乘法和初步了解逆矩阵
  - 点乘法 将右矩阵看作为多列向量或左矩阵看作为多行向量 两个矩阵都看作为向量
  - 矩阵分块相乘
  - 通过结合律判断矩阵是否是逆矩阵 如果可以找到一个量与矩阵相乘为0 则不是逆矩阵
  - 通过高斯-诺尔消元法 计算矩阵的逆矩阵
2. 逛github
  - 部署了一个总结热点的
  - 打算部署一个看youtube的 失败了
  - 花费时间过多
3. 下载了书籍的数据原 并读写
  - read_csv 的可选项 skiprows去行 
  - 对于缺失值的处理
4. 反思
 - 看书时走神过多 应该安排在上课的时候看
 - 花费在git和github时间过多 git推送文件太大 后续处理许久
## 12-31
1. mit 矩阵A的LU分解
  - 矩阵的转置和逆计算 顺序可以颠倒
  - 矩阵A乘消元矩阵E等于上三角U 两边同时乘以E的逆矩阵同时也会是下三角L 得A=LU
  - 有时候U会分裂 成主元矩阵及对角矩阵D乘以U 则A=LDU
  - 如果在对矩阵A消元的时候没有交换行的位置 消元所有的乘数可以直接填进L中
  - 矩阵N*N的运算量为N^3/3 
2. 微积分
  - x趋向负无穷的有理函数的极限 主要留意偶次方根
  - 包含绝对值的函数极限 当极限趋于正无穷或负无穷时 极限不存在
3. 使用其他分隔符格式
  - 当使用python自带的csv_read后 可定义csv.Dialect的子类 专门处理
  - 对于json数据的了解和pd处理
4. 逐块读取文本文件与数据写入
  - 提前通过options.display.max_rows限定pandas
  - nrows指定读取行数 
  - chunsize指定行数进行分块 返回可迭代
  - to_csv 数据导出逗号分隔 sep指定分隔符 
  - to_csv 缺失值默认空白符 na_sep指定缺失值
5. 3b1b逆矩阵 列空间 零空间
  - 逆矩阵即反向追踪向量
  - 列空间即对矩阵或向量的所有线性组合的大小之和
  - 零空间即在列空间基础上使线性线性组合为零
  - RANk 即维度 当最大维度被压缩时 会产生相应的维度压缩到零向量
6. 反思
 - 可以在加上碎片化时间中学习

# 2026
## 1-1
1.  mit 转置 置换 向量空间
  - 复习昨日内容 A=LU 其中LU主对角线为1 L下方为消元数
  - 当A的主原为0 对A进行置换及乘以置换矩阵P 置换的所有可能次数为n！
  - 所有置换矩阵都可逆 同时逆等于转置
  - 对于A矩阵的转置Aij=Aji
  - A矩阵与A矩阵的转置相乘结果为对称矩阵 证：当对(AA')进行转置变为A'A
  - 向量空间与昨天的3b1b中的差不多 扩张了子空间即零空间 包括了本身维度 低次维度 和零向量
2. 3b1b 对于非矩阵的理解
  - 列数即原空间维度 行数即目标向量的维度 
  - 当列数大于行数 有多条向量在维度上
  - 当列数小于行数 将向量从二维映射到三维
3. 普林斯顿 连续性
  - 对于在一点上连续 当函数f中的x趋向于a 并且极限为函数的a 前提双侧极限存在 x=a处有定义
  - 对于区间[a,b]上连续 区间上的点连续 点x=a处右连续 点x=b处左连续
  - 所有指数函数和对数函数都是连续的
  - 介值定理 当函数在X轴上下有一点作曲线 则必定会有函数等于0 对于两个上下函数也相同
  - 连续函数存在最大与最小值 必须在必区间
4. Python for Data Analysis后统称PDA 对于不同数据格式的了解
  - XML与HTML
  - 二进制数据格式
  - excel
  - HDF5
5. 反思
  - 对于mit视频的配套数据《线性代数导论》使用的还不够好 应该提前预习在看视频
## 1-2
1. MIT 列空间与零空间
  - 对于在三维空间的中有平面P和直线L L不在P上 P∪L no子空间 P∩L 有子空间0 
  - 在P∩L的基础上任取两个向量的线性组合依旧是子空间
  - 矩阵A的列空间由所有列的线性组合构成即子空间b
  - 对Ax=b 当b是A的线性组合时 x有解
  - 矩阵A中可能包含无有列 即前列的线性组合
  - 在列空间基础上使Ax=b中的b为零 即找到A的线性组合为零 这个线性组和即是零空间 零空间的线性组合与A相乘还是使b为零
  - 对于齐次方程组的解没有零向量 所有不构成子空间
2. 3b1b 点积与对偶性
  - A:向量的点积即某向量V对另一个向量W的投影乘以W 
  - 点积大于0 方向相同 等于0 垂直 小于0 反方向
  - B:变化矩阵即单位矩阵在线性变化后的值 与原向量相乘即可求出变化后的向量
  - A=B
3. 普林斯顿 可导性1
  - 举了一个类似3b1b的汽车问题 复习了导数公式的证明和推导过程
  - 通过函数（x，f（x））的切线的斜率是X的一个函数 这个函数被称为f的导数
4. PDA 与web ApI和sql交互
  - requests对api访问并读取为df
  - 通过sqilte的sqllite的使用运行sql语句
5. PDA 处理缺失值
  - isna识别 
  - dropna过滤所有含有缺失值的行 可使用how="all" 只丢弃全为缺失值的行 thresh可选择多少个缺失值就丢弃 
  - fillna填充
6. PDA 删除重复数据 函数和映射数据转换 替换值 重命名索引 离散化和分箱 检测和过滤异常值 置换和随机采样
  - duplicated判断是否重复 drop_duplicates 只保留不是重复的行 
  - map（函数或要与原表格映射的对象）
  - replace（原始值，要替换的值
  - map也可以更换索引即重命名当会要修改原始表格 rename则不会
  - cut（原数据，分组的边界）将数据分组 返回特殊分类对象 labels设置组名 如果没有分组边界只有数量 则会取等长的组
  - qcut平均分布 可传递分位数 百分比即0-1
7. 反思
  - 提升专注力在看书上  
## 1-3
1. mit 可解Ax=0 主变量，特解
  - Ax=0 当给A消元只改变列空间 而不改变零空间或解
  - 当某一列j的主元为零并且找不到非零的行变换 说明j是其他j的线性组合
  - R=主元的个数，主元所在的j为主列 其他的是自由列
  - 自由列的解是自由变量 一般任取一个自由变量为1 其余为零
  - 通过自由变量解得的x为特解
  - 任意线性组合的不同x还是在零空间中 
  - A：m*n 自由变量的数量为n-r
  - 对于行阶梯矩阵U 在进行化简 将主元上下化为0
  - 最后有Rx=0 将R拆分为主列组成的矩阵I 自由列组成的矩阵F
  - x=N（零空间矩阵）=[-F I](这是向量竖着的 不是行)
  - A主列的个数与A的转置一样
2. 普林斯顿 作为极限比的函数
  - 求导公式的一个解释 当y=x，求导的y'
  - 当x发生微小变化，y会产生大约y’倍的变化
  - 当变化越小，结果与正确结果越进
  - df/dx不是分数，是对f的求导
3. 线性函数的导数
  - y=mx+b m是斜率 就是导数
  - 当m为0 f’（X）=0
  - 二阶导数即导出的函数再次求导
  - d^(n)y/d^(n)表示 n为正整数
4. 何时导数不存在
  - 对于f（X）=|X| 的求导 缺少在0的定义
  - 可改为左导数和右导数
5. 总结可导性和连续性——每一个可导函数也是连续的
6. 求导
  - 证明了1/x 导出为1/2根号下x
  - 证明了x^a 导出为ax^a-1
7. 乘积法则与商法则
  - h（x）=f（x）g（x）h‘（x）=f'(x)g'(x)+f'(x)g'(x)
  - 当y=x=uv dy=v*dy/dx+u*dy/dx
  - uvw 总之每一个变量进行微分
  - 分数分子为乘积法则 分母平法
8. 3b1b 导数定义与极限
  - 导数定义复习
  - 任给一个数无限接近函数的极限值的数，总能找到相应范围内的任一取值
9. 洛必达法则
  - 适用于极限为0/0或无穷比无穷
  - 运用导数对上下分母同时求导
  - 本质上对求两个函数的微小变化量的倍数
10. PDA 计算指标
  - 对于矩阵df中的一列取出创建新的df（1or0）pd.get_dummies(列，prefix在新的列名加前缀)
  - 如果提取的列中有某行含有多个分类 str.get_dummies(分隔符)
  - 对于新矩阵加前缀 add_prefix
  - pd.get_dummies and pd.cut等离散函数结合使用
11. 扩展数据类型
  - pd类型 Int64Dtype StringDtype
12. python内置字符串对象方法
  - split（分隔符）拆分字符串 常搭配strip去空白符
  - 分隔符.join(字符串) 传入列表或元组
  - 子字符串 in 字符串 返回布尔值
  - index find查找并返回位置 count（）字符串出现次数 replace 替换
13. 正则表达式 类似ctrl+h 查找替换
  - re.split(查找值，数据) re.complie赋定义 重复使用 定义.findall（数据）返回符合定义的值
  - match只匹配起始位置的值 search只返回第一匹配值
14. pd的字符串函数
  - 数据.str.contains(查找值) 返回是是否在里面
  - 定义.findall（数据，flags=re.IGN）
15. 背景和目标
  - 背景就是都有几个数
  - 目标就是都是什么数
  - 两个向量映射
15. pd的分类扩展类型和计算
  - astype(category) 装化为分类扩展类型
  - 包含背景categories-object和目标codes-数量
  - 分箱函数qcut会返回categoriy
  - categoriy占有内存小
16. 分类方法
  - cat.codes 访问并返回
17. 总结一周
  - 复习一周内容
  - PDA学完第七章了 开始实践一些小工具
## 1-4
1. mit 可解性和解的结构 线性相关 及部分基
  - A增广右侧向量b=[Ab] 有解当b属于C（A）
  - 先求特解，设自由变量全为0，解的Xp 再加上零空间的任意向量Xn 即为所有解X=（Xp+Xn） 
  - 类似一个向量加上零空间 零空间过向量
  - 当r=n<m 没有自由向量 只有零个解或者一个解 N（A）=只有零向量 Ax=0 R=[I下面0] 当r=m<n 必然有解 R=[IF] 当r=m=n R=I 有唯一解 当r<m,r<n R=[IF下面00]有零个解和无线个解
  - 矩阵的r决定了方程组的解数目
  - 向量X1,X2,……Xn，进行线性组合，结果为0，则线性相关 不是0 则线性无关（组合除了0以外）及C1X1+C2X2+……CnXn ！= 0
  - 如果向量里有0，不是无关
  - m表维度，n表个数
  - 当n>m时，自由变量n-m则在维度上，表线性相关反则相反
  - Ac=0 c为非零向量 当结果为0 线性相关
  - 在列空间中有一组"基"是一系列的向量组成的向量组 基是线性无关 并且可以生成整个空间
2. 普林斯顿
  - 通过链式法则求复合函数的导数 H(x)=f(g(x)),h'(x)=f'(g(x))g'(X)=dy/dx=dy/du*du/dx
  - 通过图形解释乘积法则 在此基础上证明链式法则
3. pd实践
  - 初步了解os Union, List, Optional 
  - 完成数据加载模块
  - pd.read（路劲，sheet_name表格（execl特有） keep_default_na保留缺失值）
  - 通过pd的str循环转化大小写
  - 完成部分时间处理模块
  - pd.to_datetime(error='coerce')将缺失值转化为pd专有的时间缺失类型
  - sort_values(by=date_col, ascending=True表示升序).reset_index重置索引(drop=True删除原索引)
  - drop_duplicates删除重复行(subset=[date_col], keep='first'保留第一次出现的)
## 1-5
1. mit 维数 部分四个基本子空间
  - 对于K^n 中会有n个向量构成基 以n个向量为列的n*n矩阵 是可逆 及r=n
  - 在给定的一个空间中 基向量的个数相等 其中的个数就是维数=主列数=r
  - 零空间维数=自由变量=n-r 在R^n
  - 行空间=A行的所有线性组合=C(A^T) 中r与列一样 在R^n
  - 左零空间即A的转置的零空间R^m
  - 列空间在R^m
2. 普林斯顿
  - 有一些极限类似于导数 实则确实可以通过求导 解的
  - 对于分段函数 进行分开求导 在判断函数
3. pd实践
  - 完成日期标准化模块 完成df标准化模块
## 1-6
1. mit
  - 对矩阵进行行变化不会改变行空间改变列空间
  - 行空间前r行为基 无论A或R 行空间以最优解在最简R表现
  - 左零A^t y=y^t A=0求左零空间 找到使矩阵产生零向量的行组合
  - 对[AI]行变化得[RE]=E[AI] 其中A是可逆的 消元后得I 即EA=R=I E为A的逆矩阵
  - 将矩阵看作向量 构建向量空间 例：M3*3有9维数 其中的子空间有上三角矩阵（有3维数）、对称矩阵等
  - 当上三角矩阵交对称矩阵有对角矩阵 并时 有所有 即M
  - 两个子空间的维度的和等于他们相交的维度加上他们和的维度
  - 可以对矩阵A 通过r=1 进行拆分为一列乘一行
  - 零空间的维数加行空间的维数=列 左零空间的维数加列空间的维数=行
  - 图 结点为行，边为列 构成子图循环的边叫回路 必然线性相关
  - Ax=0 结点电势为x 当A与x相乘获得A即各边上的电势差
  - 其向量空间的解即常数c决定了结点电势的上升或下降
  - 会有回路的图叫做树 N(A^t)=m-r=相互无关的回路数量=边的数量-结点数量-1
2. 实践
  - 非常简陋的完成了
  - 无检查出传入的列名没有正确拆分 函数定义忘了return
  - .gt(0)等价>0 
  - 了解了四分位数法IQR IQR = Q3 - Q1 异常值下限：Q1 - 1.5 × IQR 异常值上限：Q3 + 1.5 × IQR
  - 文件名不可是数字开头的 保存文件要指定为具体名
## 1-7
1. mit 复习所学
  - 复习为主 
  - N(CD)=N(D) if C是可逆的
2. 实践项目
  - 了解tushare 老牌财经接口包
  - warings python的警告处理库
  - warning.filterwarning('ignore) 会忽略警告 不是报错
## 1-8
1. 学期项目
  - load_dotenv() 将本地文件.env 中的配置信息传到python中
  - datetime.now() 返回本地时间datetime strfitme是前面的专属方法 将datetime转化为指定格式字符串
  - bs的login（）返回error_code 0和error_msg success为成功 当登录失败error_msg返回错误原因
  - while (rs.error_code == '0') & rs.next() 同时满足即没有报错 和下一行有内容
  - pd.concat() 合并表格和向量ignore_index=True 重置行索引
  - apply() 对选中的每一列（或每一行）应用指定的函数
  - pd.to_numeric() 自动识别数字格式并转化 errors='coerce' 则不报错转为NaN ='raise' 直接报错 ='ignore' 不处理
  - 初步了解PE市盈率 以当前股价买入 靠公司的盈利 多少年能回本 
  - PB市净率 以当前股价买入 付出的价格是公司账面净资产的多少倍 
  - 换手率 当天有多少比例的流通股被换手交易了
  - pd.rename(改名的行或列=字典，inplace=true直接修改源文件)
2. MIT
  - 正交是垂直的一种说法在n维空间两个向量的夹角为90度
  - 判断条件为X^y=0 对于x的平法 做法是x的装置与x相乘
  - 子空间正交，即两个子空间的所有向量正交
  - 行空间正交零空间 列空间正交转置零空间
  - 无论在R^n R^m中都有正交补
  - Ax=b A^t A x=A^t b 中的x是最优解 N(A^tA)=N(A)
## 1-9
1. py实践
  - pd.merge（合并的df，on=通过哪列合成,how=保留哪一边的行） 
  - sqlite3.connect 链接数据库和python .cursor 获取数据库游标对象
  - CREATE TABLE IF NOT EXISTS 数据库表 创建数据库表 如果存在就跳过（
  - PRIMARY KEY 设为主键即无重复值 INTEGER 整数类型 取值范围小AUTO_INCREMENT 自动从一往后排不重复
  - VARCHAR(20) NOT NULL 20个字符串类型 不有非空
  - FLOAT浮点数值 BIGINT 大整数 UNIQUE（列名）不重复
  - cursor.execute(指令) 提交指令并执行 conn.commit() 永久保存到数据库中
  -INSERT …… INTO 插入数据字段即列名 OR REPLACE 对INSERT优化补充 如果插入数据不符合主键时 抛出数据重复  VALUES 具体值
  - format() 填充可变变量 .values提取纯数据剔除索引 转化为np的二维数据 .tolist() 转化为python列表
  - .executemany(模板，数据 .fetchone 返回查询的第一条数据
  - tushare没有积分 更换baostock
2. mit
  - 向量b投影e=b-p 垂直点p=xa 于向量a
  - 求上述的x 因为垂直 x^T y = a^T (b-xa) = 0 化解得 x=a^Tb/a^Ta=P=投影矩阵 矩阵的r取决a有多少r 并且只有当向量b改变时跟随改变 a改变不变 
  - 带入原公式 得 p=xa=Pb=p^T=p^2
  - 对于无解的Ax=b将b变成最接近列空间的的那一个即投影向量 求在Ax^=p的最优解x^
  - 同样的A^T(b-Ax)=0 解投影矩阵P=A (A^T A)^-1 A^T 
  - (b-Ax)=e e在零空间中 又根据之前所学 可得e垂直A的列空间
## 1-10
1. 实践
  - bs.next() 创建游标自动移动到下一个数据返回布尔值 get_row_data()搭配使用提出单条py列表数据
  - list(set( 转化为set类型去重复 再转化回list
  - Baostock没有换手率 将日线与财务合并
  - pd.date_range(start+end / periods ，freq=B交易日/D全部默认) 生成日期序列
2. mit
  - 当b在A的列空间时，Pb=b 当b垂直A的列空间时，Pb=0
  - 最优解的p加上投影到列空间垂直的零空间e=Ax=b p与e垂直 e垂直于列空间即b
  - p+e=b p=Pb e=（I-P）b =Ax-b即误差 误差的平方和即最小二乘 在图像上表示为点到最优直线的投影
  - 在统计学中会存在偏离正常数据较大的值即为离散值
  - 线性无关 A^TA 是可逆的 如果矩阵可逆零空间中只有零向量
  - 互相垂直的向量都是线性无关 矩阵各列都是正交的即标准正交
## 1-11
1. 实践
  - plt.rcParams 对全局配置如字体 颜色等 font.sans-serif 默认字体 无中文SimHei 黑体 axes.unicode_minus 坐标轴的unicode负号渲染=False 关闭 设置中文字体后负号显示为方框或消失的问题
  - pd.read_sql_query（sql查询指令，数据库接口）返回df
2. MIT
  - 向量qi^T *qi = 1的平方 在矩阵中两向量互相垂直正交 * = 0
  - 标准正交矩阵Q Q^T*Q=I 如果还是方阵Q^T=Q6-1
  - 阿德玛矩阵由1与-1组成
  - 对于标准正交矩阵Q投影到列空间 P=Q(Q^TQ)^-1Q^T=QQ^T 如果还是方阵=I 投影矩阵对称
  - 标准正交矩阵Q=[q/(q^2)的平方] 原向量做垂直另一向量 使两向量垂直 即不同的向量q=e=原向量-p
  - 原矩阵与标准矩阵的列空间一直 A=QR   r为上三角 因为垂直
## 1-12
1. 实践
  - sort_values(by=按什么排序) reset_index(drop=True) 重置规整行号，删掉旧索引
  - 计算日收益率=(当日收盘价-前日收盘价)/前日收盘价）.pct_chage() 
  - .dropna(subset=删除指定的行的缺失值
  - 收益率的瞬时变化率=今天的日收益率 - 昨天的日收益率 .diff() .dot相乘
  - :.4f针对浮点型保留4位小数 1e-8 兜底防止分母为0
  - .std() 标准差计算 标准差标准化 以均值为中心的波动大小 单只股票的因子值 - 该因子均值，再除以该因子标准差
  - 权重矩阵 例如更看重公司盈利（PE）：设为 PE=0.6/PB=0.4；
  - .flatten() 将多维矩阵压缩为一维
  - tolist() 把numpy的格式转化为py的列表
  - .groups.keys() 提取组中的键
  - set() 集合格式 元素唯一 intersection() 求交集
2. mit
  - 单位矩阵的行列式的值是1 交换行 行列式的值符号相反 寄正偶负
  - 一个数乘以一行 可以提出数 相交 可以分裂相加 每一行都是线性函数
  - 两行相等=0 一行全是0值也等于0 可逆不会出现全0行
  - 进行消元行列式不变 2A矩阵=2^n A向量
  - 装置行列式=原行列式
## 1-13
1. 实践
  - .issubset判断前面的集合是否在另一个集合中 
  - plt.plot折线图(水平反向数据，垂直数据，label=图的名字,color=颜色,linewidth=折线的大小)
  - title标题 xlabel横轴说明 ylabel竖轴说明 legend图例 fontsize字体大小 grid(True添加网格线，alpha透明度 xticks(rotation=45) 旋转x轴字体45度 tight_layout()自动优化 plt.show(block=False) 让显示的图表不堵塞程序运行
  - .pct_change() 计算相邻数据变化的百分比 
2. mit
  - 行列式值=求和负n!+-a1j+a2j+a3j……anj
  - 代数余子式选择行列式某一行或列考虑所有可能性并相加即去掉选择的ji，剩余组成的行列式，当i+j是偶数时符号是正反之为负
  - 代数余子式|An| = |An-1| - |An-2| A^-1 = 1/行列式值 C^T 其中C是伴随矩阵即原矩阵的代数余子式还是由n-1个元素组成的矩阵
  - AC^T = 对角线为行列式值的单位矩阵 原矩阵的行乘以代数余子式并相加=行列式的值
  - Ax=b x=A^-1 b = 1/detA C^T b xj = detBj/detA detBj = 沿第j列为b的代数余子式相加
  - 平行四边形面积ad-bc 三角形是一半