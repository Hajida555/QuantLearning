# 2025
##  12-27
1. 函数应用和映射
  - numpy的函数可以对pandas的对象使用(例如np.abs(DataFrame) or 多个值组成的Series)
  - 并且可以具体使用到行和列中(例如使用DataFrame.**apply**(函数) 默认为列)
  - 对于元素级的Python的函数可以使用**map**
2. 排列和排名（类似sql）
  - sort_index() 对于Series or DataFrame默认按索引排列和升序 降序ascendin=False
  - sort_values() 则是按值排列 当对DataFrame排序时，可以使用一列或多列的的数据作为排序键
  - 任何缺失值都会放到Series的末尾 反过来na_position="first"
  - rank() 为数据的值排名 默认相同的值取平均数(例如 1 2 2.5 2.5)
  - 如果想让rank按原数据中出现的顺序排名 method="first" 这样会从最小值1一直排到底
  - rank的降序也与排列一样 ascendin=False
  - 同样rank可以使用一列或多列的的数据作为排名键
3. 对于带有重复标签的索引的处理
  - 对index使用is_unique可以得知索引是否是唯一的
  - if 索引对应多个值 return Series if 为单个则与平常一样 return 单个值
  - 对DataFrame同样生效
  - 但是上述操作会使代码复杂化
## 12-28
1.  3Blue1Brown学习了指数函数求导和隐函数求导
  - 指数函数在在短时的变化率等于自身乘以一个常数 当底数为e时 常数为一
  - 通过链式法则 推出e^常数*t = 常数^t
  - 当x发生短时变化，y也随之变化 求导求的就是变化的比例
  - 当x和y给定一个，有对应的另一个便是隐形函数 求导只是链式法则的灵活运用
2. 普林斯顿第三章 极限
  - 更系统的复习一遍
3. 汇总统计和间接统计
  - sum and mean等 对na不同情况的处理方式 汇总统计
  - idxmax and idmin等 输出列和行的是索引 间接统计 
  - cumsum 每一行向下列不停加 累加统计
  - descible 一次性输出多种汇总统计
4. 获取a股股票数据的工具推进
  - bs.query_history_k_data_plus函数的初步认识
5. 整理和反思
  - 将这学期之前所学的excel sql整理
  - 大部分都已经遗忘 需要找时间重新温习
  - 许多知识还没有彻底掌握 需要多加记录和巩固
## 12-29
1. 矩阵消元和方程组的几何解释 MIT
  - 通过向量和图形来求解二维和三维的方程组 与3b1b的图形解释相像
  - 向量的和矩阵的多种乘法
  - 用矩阵消元做出下三角行列式 回代解方程组
  - 矩阵乘法不同的行列相乘
  - 作了一点课后习题
2. 完成获取a股股票数据的工具
  - 处理数据为df 文件名称正常 不同系统路径的格式 
3. 使用导出数据 了解相关系数和协方差
  - 相关系数CORR 协方差cov
  - 相关系数表明两个数据之间的关联有多强 1-0 越大越有关系
  - 协方差表明两个数据之间是否同向 正数为同一个方向 负数两个数据为反向
4. 唯一值、计数及成员属性
  - uniques去重复无排序 加sort()排序
  - value_counts 计算值出现的频次 按降序
  - isin筛选条件并返回布尔值可为数据集过滤为子集
  - index.get_indexer 根据一个索引列表对提供的有重复的列表 输出重复列表在索引的位置
  - data.apply(lambda obj: pd.Series(obj).value_counts()).fillna(0) 对df中出现过的所有值在不同列出现次数计数
  - df.value_counts() 则是按照每一行为元组进行计数
## 12-30
1. 矩阵的多种乘法和初步了解逆矩阵
  - 点乘法 将右矩阵看作为多列向量或左矩阵看作为多行向量 两个矩阵都看作为向量
  - 矩阵分块相乘
  - 通过结合律判断矩阵是否是逆矩阵 如果可以找到一个量与矩阵相乘为0 则不是逆矩阵
  - 通过高斯-诺尔消元法 计算矩阵的逆矩阵
2. 逛github
  - 部署了一个总结热点的
  - 打算部署一个看youtube的 失败了
  - 花费时间过多
3. 下载了书籍的数据原 并读写
  - read_csv 的可选项 skiprows去行 
  - 对于缺失值的处理
4. 反思
 - 看书时走神过多 应该安排在上课的时候看
 - 花费在git和github时间过多 git推送文件太大 后续处理许久
## 12-31
1. mit 矩阵A的LU分解
  - 矩阵的转置和逆计算 顺序可以颠倒
  - 矩阵A乘消元矩阵E等于上三角U 两边同时乘以E的逆矩阵同时也会是下三角L 得A=LU
  - 有时候U会分裂 成主元矩阵及对角矩阵D乘以U 则A=LDU
  - 如果在对矩阵A消元的时候没有交换行的位置 消元所有的乘数可以直接填进L中
  - 矩阵N*N的运算量为N^3/3 
2. 微积分
  - x趋向负无穷的有理函数的极限 主要留意偶次方根
  - 包含绝对值的函数极限 当极限趋于正无穷或负无穷时 极限不存在
3. 使用其他分隔符格式
  - 当使用python自带的csv_read后 可定义csv.Dialect的子类 专门处理
  - 对于json数据的了解和pd处理
4. 逐块读取文本文件与数据写入
  - 提前通过options.display.max_rows限定pandas
  - nrows指定读取行数 
  - chunsize指定行数进行分块 返回可迭代
  - to_csv 数据导出逗号分隔 sep指定分隔符 
  - to_csv 缺失值默认空白符 na_sep指定缺失值
5. 3b1b逆矩阵 列空间 零空间
  - 逆矩阵即反向追踪向量
  - 列空间即对矩阵或向量的所有线性组合的大小之和
  - 零空间即在列空间基础上使线性线性组合为零
  - RANk 即维度 当最大维度被压缩时 会产生相应的维度压缩到零向量
6. 反思
 - 可以在加上碎片化时间中学习

# 2026
## 1-1
1.  mit 转置 置换 向量空间
  - 复习昨日内容 A=LU 其中LU主对角线为1 L下方为消元数
  - 当A的主原为0 对A进行置换及乘以置换矩阵P 置换的所有可能次数为n！
  - 所有置换矩阵都可逆 同时逆等于转置
  - 对于A矩阵的转置Aij=Aji
  - A矩阵与A矩阵的转置相乘结果为对称矩阵 证：当对(AA')进行转置变为A'A
  - 向量空间与昨天的3b1b中的差不多 扩张了子空间即零空间 包括了本身维度 低次维度 和零向量
2. 3b1b 对于非矩阵的理解
  - 列数即原空间维度 行数即目标向量的维度 
  - 当列数大于行数 有多条向量在维度上
  - 当列数小于行数 将向量从二维映射到三维
3. 普林斯顿 连续性
  - 对于在一点上连续 当函数f中的x趋向于a 并且极限为函数的a 前提双侧极限存在 x=a处有定义
  - 对于区间[a,b]上连续 区间上的点连续 点x=a处右连续 点x=b处左连续
  - 所有指数函数和对数函数都是连续的
  - 介值定理 当函数在X轴上下有一点作曲线 则必定会有函数等于0 对于两个上下函数也相同
  - 连续函数存在最大与最小值 必须在必区间
4. Python for Data Analysis后统称PDA 对于不同数据格式的了解
  - XML与HTML
  - 二进制数据格式
  - excel
  - HDF5
5. 反思
  - 对于mit视频的配套数据《线性代数导论》使用的还不够好 应该提前预习在看视频
## 1-2
1. MIT 列空间与零空间
  - 对于在三维空间的中有平面P和直线L L不在P上 P∪L no子空间 P∩L 有子空间0 
  - 在P∩L的基础上任取两个向量的线性组合依旧是子空间
  - 矩阵A的列空间由所有列的线性组合构成即子空间b
  - 对Ax=b 当b是A的线性组合时 x有解
  - 矩阵A中可能包含无有列 即前列的线性组合
  - 在列空间基础上使Ax=b中的b为零 即找到A的线性组合为零 这个线性组和即是零空间 零空间的线性组合与A相乘还是使b为零
  - 对于齐次方程组的解没有零向量 所有不构成子空间
2. 3b1b 点积与对偶性
  - A:向量的点积即某向量V对另一个向量W的投影乘以W 
  - 点积大于0 方向相同 等于0 垂直 小于0 反方向
  - B:变化矩阵即单位矩阵在线性变化后的值 与原向量相乘即可求出变化后的向量
  - A=B
3. 普林斯顿 可导性1
  - 举了一个类似3b1b的汽车问题 复习了导数公式的证明和推导过程
  - 通过函数（x，f（x））的切线的斜率是X的一个函数 这个函数被称为f的导数
4. PDA 与web ApI和sql交互
  - requests对api访问并读取为df
  - 通过sqilte的sqllite的使用运行sql语句
5. PDA 处理缺失值
  - isna识别 
  - dropna过滤所有含有缺失值的行 可使用how="all" 只丢弃全为缺失值的行 thresh可选择多少个缺失值就丢弃 
  - fillna填充
6. PDA 删除重复数据 函数和映射数据转换 替换值 重命名索引 离散化和分箱 检测和过滤异常值 置换和随机采样
  - duplicated判断是否重复 drop_duplicates 只保留不是重复的行 
  - map（函数或要与原表格映射的对象）
  - replace（原始值，要替换的值
  - map也可以更换索引即重命名当会要修改原始表格 rename则不会
  - cut（原数据，分组的边界）将数据分组 返回特殊分类对象 labels设置组名 如果没有分组边界只有数量 则会取等长的组
  - qcut平均分布 可传递分位数 百分比即0-1
7. 反思
  - 提升专注力在看书上  
## 1-3
1. mit 可解Ax=0 主变量，特解
  - Ax=0 当给A消元只改变列空间 而不改变零空间或解
  - 当某一列j的主元为零并且找不到非零的行变换 说明j是其他j的线性组合
  - R=主元的个数，主元所在的j为主列 其他的是自由列
  - 自由列的解是自由变量 一般任取一个自由变量为1 其余为零
  - 通过自由变量解得的x为特解
  - 任意线性组合的不同x还是在零空间中 
  - A：m*n 自由变量的数量为n-r
  - 对于行阶梯矩阵U 在进行化简 将主元上下化为0
  - 最后有Rx=0 将R拆分为主列组成的矩阵I 自由列组成的矩阵F
  - x=N（零空间矩阵）=[-F I](这是向量竖着的 不是行)
  - A主列的个数与A的转置一样
2. 普林斯顿 作为极限比的函数
  - 求导公式的一个解释 当y=x，求导的y'
  - 当x发生微小变化，y会产生大约y’倍的变化
  - 当变化越小，结果与正确结果越进
  - df/dx不是分数，是对f的求导
3. 线性函数的导数
  - y=mx+b m是斜率 就是导数
  - 当m为0 f’（X）=0
  - 二阶导数即导出的函数再次求导
  - d^(n)y/d^(n)表示 n为正整数
4. 何时导数不存在
  - 对于f（X）=|X| 的求导 缺少在0的定义
  - 可改为左导数和右导数
5. 总结可导性和连续性——每一个可导函数也是连续的
6. 求导
  - 证明了1/x 导出为1/2根号下x
  - 证明了x^a 导出为ax^a-1
7. 乘积法则与商法则
  - h（x）=f（x）g（x）h‘（x）=f'(x)g'(x)+f'(x)g'(x)
  - 当y=x=uv dy=v*dy/dx+u*dy/dx
  - uvw 总之每一个变量进行微分
  - 分数分子为乘积法则 分母平法
8. 3b1b 导数定义与极限
  - 导数定义复习
  - 任给一个数无限接近函数的极限值的数，总能找到相应范围内的任一取值
9. 洛必达法则
  - 适用于极限为0/0或无穷比无穷
  - 运用导数对上下分母同时求导
  - 本质上对求两个函数的微小变化量的倍数
10. PDA 计算指标
  - 对于矩阵df中的一列取出创建新的df（1or0）pd.get_dummies(列，prefix在新的列名加前缀)
  - 如果提取的列中有某行含有多个分类 str.get_dummies(分隔符)
  - 对于新矩阵加前缀 add_prefix
  - pd.get_dummies and pd.cut等离散函数结合使用
11. 扩展数据类型
  - pd类型 Int64Dtype StringDtype
12. python内置字符串对象方法
  - split（分隔符）拆分字符串 常搭配strip去空白符
  - 分隔符.join(字符串) 传入列表或元组
  - 子字符串 in 字符串 返回布尔值
  - index find查找并返回位置 count（）字符串出现次数 replace 替换
13. 正则表达式 类似ctrl+h 查找替换
  - re.split(查找值，数据) re.complie赋定义 重复使用 定义.findall（数据）返回符合定义的值
  - match只匹配起始位置的值 search只返回第一匹配值
14. pd的字符串函数
  - 数据.str.contains(查找值) 返回是是否在里面
  - 定义.findall（数据，flags=re.IGN）
15. 背景和目标
  - 背景就是都有几个数
  - 目标就是都是什么数
  - 两个向量映射
15. pd的分类扩展类型和计算
  - astype(category) 装化为分类扩展类型
  - 包含背景categories-object和目标codes-数量
  - 分箱函数qcut会返回categoriy
  - categoriy占有内存小
16. 分类方法
  - cat.codes 访问并返回
17. 总结一周
  - 复习一周内容
  - PDA学完第七章了 开始实践一些小工具